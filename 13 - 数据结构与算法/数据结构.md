[TOC]

# 分类

*   线性表：数组、链表、双向链表、双向循环链表、栈、队列 等
*   树结构：堆、普通树、二叉树 等
*   图结构
*   哈希表



# 线性表

### 栈和队列

##### 简介

*   栈和队列都是线性数据结构
*   栈只能从一端进，只能从同一端出，是先进后出的数据结构
*   队列能从一端进，只能从另一端出，是先进先出的数据结构



##### 应用场景

栈的应用：软件中的撤销操作、浏览器中的回退操作、编译器中的函数调用实现等

队列的应用：数据流、异步的传输结构、排队



##### 实现

栈的实现：

|      接口      |       说明       |    复杂度     |
| :------------: | :--------------: | :-----------: |
| void push(E e) |  向栈中加入元素  | O(1) **均摊** |
|    E pop()     |   弹出栈顶元素   | O(1) **均摊** |
|    E peek()    |   查看栈顶元素   |     O(1)      |
| int getSize()  | 获取栈中元素个数 |     O(1)      |
| bool isEmpty() |  判断栈是否为空  |     O(1)      |

队列的实现：

|       接口        |       说明       |    复杂度     |
| :---------------: | :--------------: | :-----------: |
| void enqueue(E e) |       入队       | O(1) **均摊** |
|    E dequeue()    |       出队       |     O(1)      |
|   E getFront()    |   获取队首元素   |     O(1)      |
|   int getSize()   | 获取队列元素个数 |     O(1)      |
|  bool isEmpty()   | 判断队列是否为空 |     O(1)      |



### 数组和链表

##### 存储结构

*   数组：在内存中是连续的，固定个数的元素
*   链表：在内存中是随机不连续的，个数也不固定的

##### 优缺点：

*   访问元素：数组访问元素效率高，因为地址是连续的；链表一般，因为需要从首个元素遍历链表
*   插入、删除元素：数组效率低，链表效率高









# 哈希

### 哈希表(散列表)

##### 意义

​	数组的特点是：访问性能好，插入和删除性能差

​	链表的特点是：访问性能差，插入和删除性能好

​	而哈希就是介于这两者之间的。

##### 基本原理

​	哈希表中所存储的每个元素，都会通过固定的哈希算法，将键值计算出一个整数值，这个数值可以用于确定哈希表内的某个位置，也就是它的键。

​	每个元素映射到唯一与之对应的键，哈希表将这个元素和它的键以键值对的形式存储在表中，通过键我们可以快速的访问到这个元素的值。



##### 哈希算法

​	实际上就是一种压缩映射，简单来说，就是将任意长度的值通过哈希算法，生成一个固定长度的值。根据算法的不同，计算出的结果也不一样，MD5就是一种经典的哈希算法。

​	**哈希算法要保证**：

*   确定性：同一个值经过哈希算法(同一算法)后得到的hash值一定是固定的
*   不可逆性：不可通过hash值反向推出原始值



##### 哈希表

​	哈希表通过把键值计算出**Hash**值后，通过**Hash**值映射到表里面的某个位置。那么同样的键值，下次访问或者修改都是同一个映射位置，不同的键值因为计算出**Hash**值不一样映射的位置也会不同。



##### 哈希冲突

​	根据抽屉原理，哈希算法是可能存在哈希冲突的，因为任意长度值的可能性是无穷尽的，而固定长度能表示的值确有限，所以虽然可能性很小，但也可能存在两个不同的值通过哈希算法映射到一个相同的值。



##### 哈希冲突解决

*   开放地址法
    *   线性探测法：出现Hash冲突后，依次查询这个键值后面的地址，找到一个空的或者全部查完没找到
    *   二次探测法：出现冲突后，对这个键值后面的地址或者前面的地址进行平方后查询
*   再哈希法：构建多个Hash算法函数，出现冲突就用其他Hash算法进行Hash，直到不冲突为止
*   开链表法：对每个位置新增一个链表，添加元素到链表中，只要链表元素不多，效率都还行







# 树结构

### 普通树

### 二叉树

### AVL树

### B+树