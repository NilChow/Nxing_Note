# 联合查询

T1表结构

| user_id | user_name | password |
| :-----: | :-------: | :------: |
|    1    |   owen    |  123456  |
|    2    |  miller   |  654321  |

T2表结构

| user_id | score | level |
| :-----: | :---: | :---: |
|    1    |  30   |   5   |
|    2    |  50   |   8   |



### 内联

内联是把两张表中的数据拼成一行。

如果想把一个**user_id**所有的信息(用户名、密码、积分、等级)都查出来，使用内联。

*   SQL：SELECT * FROM T1, T2 WHERE T1.user_id=T2.user_id

还有另一种更高效的写法，一般使用这种：

*   SQL：SELECT * FROM T1 INNER JOIN T2 ON T1.user_id=T2.user_id









# 高级

### 事务

​	MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你既需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务。

要点：

*   在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务
*   事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行
*   事务用来管理 insert,update,delete 语句



​	一般来说，事务是必须满足4个条件（ACID）：：原子性（**A**tomicity，或称不可分割性）、一致性（**C**onsistency）、隔离性（**I**solation，又称独立性）、持久性（**D**urability）。

##### 原子性

​	一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。

##### 一致性

​	在事务开始之前和事务结束以后，数据库的完整性没有被破坏。

##### 隔离性

​	数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。

​	事务隔离分为不同级别：

*   读未提交（Read uncommitted）
*   读提交（read committed）
*   可重复读（repeatable read）
*   可序列化（Serializable）

| 隔离级别 |               读数据一致性               | 脏读 | 不可重复读 | 幻读 |
| :------: | :--------------------------------------: | :--: | :--------: | :--: |
| 读未提交 | 最低级别，只能保证不读取物理上损坏的数据 |  是  |     是     |  是  |
|  读提交  |                  语句级                  |  否  |     是     |  是  |
| 可重复读 |                  事务级                  |  否  |     否     |  是  |
| 可序列化 |             最高级别，事务级             |  否  |     否     |  否  |



##### 持久性

​	事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。



### 存储引擎

##### MyISAM

##### InnoDB



### 索引 树结构

##### MongoDB -- B树

​	MongoDB使用B树，所有节点都有Data域，只要找到指定索引就可以进行访问，无疑单次查询平均快于Mysql

##### MySQL -- B+树

​	Mysql作为一个关系型数据库，数据的关联性是非常强的，区间访问是常见的一种情况，B+树由于数据全部存储在叶子节点，并且通过指针串在一起，这样就很容易的进行区间遍历甚至全部遍历



### 性能优化的21个最佳实践

##### 1. 为查询缓存优化查询语句

##### 2. Explain查询语句

##### 3. 只要一行数据时使用limit 1

##### 4. 为搜索字段创建索引

##### 5. Join时使用相同类型的列，并为其创建索引

##### 6. 千万不要 order by rand()

##### 7. 尽量避免 select *

##### 8. 永远为每张表设计一个ID

##### 9. 优先使用ENUM而不是VARCHAR

##### 10. 从PROCEDURE ANALYSE()取得建议

##### 11. 尽可能的使用NOT NULL

##### 12. prepared staments

##### 13. 无缓冲的查询

##### 14. IP地址的存储类型选为UNSIGNED INT

##### 15. 固定长度的表会更快

##### 16. 垂直分割

##### 17. 拆分大的 DELETE 和 INSERT 语句

##### 18. 越小的列(字段)会越快

​		把数据变紧凑，减少对硬盘的访问

##### 19. 选择正确的存储引擎

###### MyISAM

*   MyISAM适用于一些需要大量查询的应用，但对大量写操作不是很友好
*   甚至只需要update一个字段，整个表都会被锁起来，而此时别的进程，连读操作都不能够执行
*   MyISAM对于SELECT COUNT(*) 这类计算是超快无比的

###### InnoDB

*   InnoDB的趋势会是一个无比复杂的存储引擎，对于一些小的应用，它会比MyISAM还慢
*   它支持行锁，在写操作的时候，会更优秀
*   它支持更多的高级应用，比如事务



##### 20. 使用对象关系映射器 (ROM -- Object Relational Mapper)



##### 21. 小心“永久链接”

